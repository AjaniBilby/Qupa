import "array.fab";

import "memory.qp" as Memory;
import "math.qp" as Math;


template <Wild^ Type>
/**
 * A variable length array
 */
class Vector extends Array<Type, 0>{
	private:
		size_t length = 0;
		size_t heap = 0;

		@Type reference = nullptr;

	public:
		void __construct__(){
			this.reference = Memory::Allocate(0);
			return;
		}
		void __construct__(int items){
			this.reserve(items);
			return;
		}
		void __construct__(int items, Type value){
			this.reserve(items, value);
			return;
		}
		void __construct__(^Container<Type> data){
			size_t length = data.length();
			this.resize(length);

			for (size_t i=0; i<length; i++){
				this[i] = data[i];
			}
		}
		void __destruct__(){
			size_t length = this.size();
			for (int i=0; i<length; i++){
				delete this[i];
			}

			Memory::Free(this.reference);

			return;
		}


		/**
		 * Makes a mirror of this vector ensuring that the elements of the new and old vector are independant
		 * @param The address to place the duplicate
		 */
		void __duplicate__(@Vector<Type> to){
			// Reserve the required space
			to.reserve( this.capacity() );
			to.resize ( this.size()     );

			// Duplicate elements individually
			//  Cater for element class behaviour
			size_t i=0;
			while (i < this.size){
				to[i] = this[i];
			}

			return;
		}

		/**
		 * Get the address of a specified element
		 * @param Specify which element by index number (starts from zero)
		 */
		@Type __get__(size_t index){
			// Check that the index is valid
			if (index >= this.size){
				throw "Index error: cannot get element " + index.toString() + " of " + this.size.toString();
			}

			return @this.reference + index;
		}

		/**
		 * Pushes the value to the vector
		 */
		Vector<Type> __add__(Type value){
			// Resize the vector to fit the new elements
			size_t i = this.length;
			this.resize(i+1);

			// Write the value
			this[i] = value;
			return;
		}
		/**
		 * Pushes the other vector to the end of this one
		 */
		Vector<Type> __add__(Vector<Type> value){
			Vector<Type> res = this;
			res.concat(value);

			return res;
		}



		/**
		 * @return The number of elements this vector can hold without resizing
		 */
		size_t capacity(){
			return this.heap;
		}
		/**
		 * @return The length of the current vector
		 */
		size_t size(){
			return this.length;
		}



		/**
		 * Increases the size of the container being used by the vector
		 * @param The number of elements the vector should now be able to hold
		 */
		void reserve(size_t items){
			// If this is a down size, first destruct the elements that will be destoryed;
			if (items < this.size()){
				this.resize(items;)
			}

			// Create a new heap
			@Type to = Memory.Allocate(items * sizeof(Type));
			size_t length = this.size();

			// Don't allow the vector to shrink pass the used items
			items = Math.max(items, length);

			// Transfer the vector elements to the new heap
			Memory::Duplicate(@this.reference, @to, min);

			// Wipe the previous vector heap.
			Memory::Free(@this.reference);

			// Mark the new heap as the vector's heap
			@this.reference = @to;

			return;
		}

		/**
		 * Changes the length of the vector to meet the specified length.
		 * This may trigger a reserve if the vector needs to expand out side it's capacity
		 * @param The number of items the vector should now hold.
		 */
		void resize(size_t items, Type value = null){
			size_t length = this.size();

			if (items > this.capacity()){
				this.reserve(items);
			}

			/**
			 * Safely destruct each item that will be removed
			 */
			for (size_t i=items; i<this.length; i++){
				this[i].__destruct__();
			}

			// Fill new elements with a default value
			if (value != null){
				for (size_t i=this.length; i<items; i++){
					this[i] = value;
				}
			}

			this.length = items;
			return;
		}



		/**
		 * Puts multiple items after the current last item.
		 * @param The elements to be added.
		 */
		void concat(^Array<Type> value){
			size_t length = this.size();

			// Resize the vector to fit the new elements
			size_t offset = length;
			this.resize(length + value.size);

			// Duplicate each element
			//   Not bytewise to cater for class behaviour
			size_t i = 0;
			size_t size = value.size;
			while (size > 0){
				this[i + offset] = value[i];

				i = i + 1;
				size = size - 1;
			}
		}



		/**
		 * Get a sub section of this Container
		 * @param Which index to start the slice at
		 * @param Which index marks the end of the slice. (The slice will not include the element at this index)
		 * @returns The subsection of the container in vector form
		 */
		Vector<type> slice(size_t start = 0, size_t end = -1){
			// Check the inputs are valid
			if (end <= start){
				throw "Cannot create a slice with starting index \""+start+"\" and end index \""+end+"\"";
			}

			// Correct the ending point
			if (end > this.size){
				end = this.size;
			}

			// Create space for a result class
			size_t size = end - start;
			Vector<type> out(size);

			// Duplicate the elements
			//  Element based to account for class behaviour
			size_t i=0;
			while (start < end){
				out[i] = this[start];

				i += 1;
				start += 1;
			}

			return out;
		}


		/**
		 * Remove X elements from this vector shifting later elements back.
		 * Also return a vector of the elements removed
		 * @returns The elements removed
		 */
		Vector<type> splice(size_t start = 0, size_t elements = 1){
			Vector<type> out(0);
			size_t length = this.size();

			// You can only splice 0 elements out side of the vector
			if (start+elements > length){
				return out;
			}

			// Ensure the splice does not go out of the array
			// If it does change the number of elements to fit within the array
			size_t end = start + elements;
			if (end > length){
				end = length;
				elements = end-start;
			}

			// Create space to store the results
			out.resize(elements);

			for (int i=0; i<length; i++){
				// Copy the element to the array
				out[i] = this[start + i];

				// Shift the element backwards
				size_t shift = start+i + elements;
				if (shift < length){
					this[start + i] = this[shift];
				}
			}

			// Resize the vector now that elements have been removed
			this.resize(elements);

			return out;
		}

		/**
		 * Remove the first element from the vector, shifting all following elements forwards
		 */
		Type shift(){
			return this.splice(0)[0];
		};


		/**
		 * Swaps the position of two elements
		 */
		void swap(size_t a, size_t b){
			Type temp = this[a];
			this[a] = this[b];
			this[b] = temp;
		};


		/**
		 * Inserts the element at the beginning of the vector pushing other items backwards
		 */
		void insert(size_t index, Type value){
			size_t length = this.size() + 1;
			this.resize(length);

			// Shift items backwards
			size_t i=length-1
			for (; i>=index; i--){
				this[i] = this[i-1];
			}

			this[index] = value;
		}
		/**
		 * Inserts elements at the beginning of the vector pushing other items backwards
		 */
		void insert(size_t i, Vector<Type> values){
			size_t length = this.size() + 1;
			size_t shift = values.size();
			this.resize(length);

			// Shift items backwards
			size_t i = length - shift;
			for (; i>=index; i--){
				this[i] = this[i - shift];
			}

			// Insert all the new items in the created blank space
			for (i=0; i<shift; i++){
				this[index+i] = values[i];
			}
		}
}
expose Vector;
